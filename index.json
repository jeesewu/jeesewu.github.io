[{"categories":["Browser"],"content":"iPhone 的 Input 元素 Viewport 缩放现象","date":"2021-04-18","objectID":"/input-viewport-zoom-on-iphone/","tags":["Safari"],"title":"iPhone 的 Input 视口缩放现象","uri":"/input-viewport-zoom-on-iphone/"},{"categories":["Browser"],"content":"1 先来看看缩放现象 iPhone 上的浏览器 Safari\\Chrome\\Firefox，会出现如下现象： 当聚焦的元素的字体大小 \u003e= 16px 时，Viewport 不缩放。 当聚焦的元素的字体大小 \u003c 16px 时，Viewport 缩放。 这个操作貌似是 Apple 为了照顾视障人士的体贴设定，但是仅对 iPhone 生效，iPad 和 Mac 都不会出现这样的现象哦。🤔 当我们有小于 16px 的 \u003cinput\u003e 元素时，点进 \u003cinput\u003e，Viewport 放大，可以理解。 但是表单提交后，\u003cinput\u003e 失去 focus 了，Apple 却不把 Viewport 缩放回原来的大小，这就蛋疼了。 ","date":"2021-04-18","objectID":"/input-viewport-zoom-on-iphone/:1:0","tags":["Safari"],"title":"iPhone 的 Input 视口缩放现象","uri":"/input-viewport-zoom-on-iphone/"},{"categories":["Browser"],"content":"2 看看网上的吐槽和解决方案 No input zoom in Safari on iPhone, the pixel perfect way 这篇文章很贴心地对这样的现象分析了前因后果，顺便还提供自己的解决方案。 总结来说，有 3 种解决方案： 把 font-size 设置为16px \u003cmeta name=\"viewport\"\u003e 禁止 Viewport 缩放 maximum-scale=1.0 user-scalable=no 伪造 16px 原始 input[type=\"text\"] { /* styles to be adjusted */ border-radius: 5px; font-size: 12px; line-height: 20px; padding: 5px; width: 100%; } 修改 input[type=\"text\"] { /* enlarge by 16/12 = 133.33% */ border-radius: 6.666666667px; font-size: 16px; line-height: 26.666666667px; padding: 6.666666667px; width: 133.333333333%; /* scale down by 12/16 = 75% */ transform: scale(0.75); transform-origin: left top; /* remove extra white space */ margin-bottom: -10px; margin-right: -33.333333333%; } ","date":"2021-04-18","objectID":"/input-viewport-zoom-on-iphone/:2:0","tags":["Safari"],"title":"iPhone 的 Input 视口缩放现象","uri":"/input-viewport-zoom-on-iphone/"},{"categories":["Browser"],"content":"3 总结 从视障关怀的角度，我可以接受缩放，我会说 Good Job, Apple! 从页面设计者的角度看，元素失去 focus 还不复原 Vieport 的操作，我会说 FXXX! ","date":"2021-04-18","objectID":"/input-viewport-zoom-on-iphone/:3:0","tags":["Safari"],"title":"iPhone 的 Input 视口缩放现象","uri":"/input-viewport-zoom-on-iphone/"},{"categories":["JavaScript"],"content":"React 中的 \"this\" 问题和解决方案","date":"2021-04-16","objectID":"/this-in-react/","tags":["JavaScript","React","this"],"title":"React 中的 \"this\"","uri":"/this-in-react/"},{"categories":["JavaScript"],"content":"0 简介 这里写的 React 中的 this 问题，其实不是 React 特有，而是 JavaScript 的，我这里仅介绍 React 中常见的情况。 this 简而言之就是：Function call this 更详细的前因后果，我可能会在有空的时候另开新一篇文章。 ","date":"2021-04-16","objectID":"/this-in-react/:1:0","tags":["JavaScript","React","this"],"title":"React 中的 \"this\"","uri":"/this-in-react/"},{"categories":["JavaScript"],"content":"1 this 错误现象 this is undefined ? 🤔 /* TypeError: Cannot read property 'setState' of undefined. 🥲 */ class ThisError extends React.Component { constructor(props) { super(props); this.state = { counter: 0 }; } handleClick(event) { this.setState((state, props) =\u003e { return { counter: state.counter + 1 }; }); } render() { return \u003cbutton onClick={this.handleClick}\u003eClick Me\u003c/button\u003e; } } ","date":"2021-04-16","objectID":"/this-in-react/:2:0","tags":["JavaScript","React","this"],"title":"React 中的 \"this\"","uri":"/this-in-react/"},{"categories":["JavaScript"],"content":"2 错误原因 this “丢失” - 在回调 handleClick() 时，可以看作如下: class ThisError extends React.Component {...} /* 上面的执行完，再 callback */ handleClick() // 这个 Function Call this 不就是 undefined 么 ","date":"2021-04-16","objectID":"/this-in-react/:3:0","tags":["JavaScript","React","this"],"title":"React 中的 \"this\"","uri":"/this-in-react/"},{"categories":["JavaScript"],"content":"3 解决方案 2 种原理： 给 this 绑定 class 中的 this。 箭头函数没有 this，它往上找最近的 this(此处是 class 的 this) 作为自己的 this。 /* 1. fix 1 - bind 😃 */ class ThisFix2 extends React.Component { constructor(props) { super(props); this.handleClick = this.handleClick.bind(this); } } /* 2. fix 2 - arrow function 😃 */ class ThisFix2 extends React.Component { handleClick = (event) =\u003e { this.setState(); }; } /* 3. fix 3 - arrow function 😆 */ class ThisFix3 extends React.Component { render() { return ( \u003cbutton onClick={(event) =\u003e this.handleClick(event)}\u003eClick Me\u003c/button\u003e ); } } ","date":"2021-04-16","objectID":"/this-in-react/:4:0","tags":["JavaScript","React","this"],"title":"React 中的 \"this\"","uri":"/this-in-react/"},{"categories":["JavaScript"],"content":"4 Codepen Example ","date":"2021-04-16","objectID":"/this-in-react/:5:0","tags":["JavaScript","React","this"],"title":"React 中的 \"this\"","uri":"/this-in-react/"},{"categories":["JavaScript"],"content":"5 总结 this 其实没啥好说的，就是 Call 决定的。 Callback 可看作在代码最底部执行（非严谨比喻）。 ","date":"2021-04-16","objectID":"/this-in-react/:6:0","tags":["JavaScript","React","this"],"title":"React 中的 \"this\"","uri":"/this-in-react/"},{"categories":["React"],"content":"React 受控组件和非受控组件","date":"2021-04-15","objectID":"/controlled-and-uncontrolled-components/","tags":["React"],"title":"受控组件和非受控组件","uri":"/controlled-and-uncontrolled-components/"},{"categories":["React"],"content":"1 Controlled Components 使用 React 时， \u003cinput\u003e 的 value 存储在 Component 的 state 里，value 受到 React 的 state 控制，只有 state 改变，渲染出来的 DOM 的 value 才改变。 ","date":"2021-04-15","objectID":"/controlled-and-uncontrolled-components/:1:0","tags":["React"],"title":"受控组件和非受控组件","uri":"/controlled-and-uncontrolled-components/"},{"categories":["React"],"content":"2 Uncontrolled Elements 指 value 存储在 DOM 里，例如 \u003cinput\u003e 的 value 属性里，没有受到 React 的 state 控制。 ","date":"2021-04-15","objectID":"/controlled-and-uncontrolled-components/:2:0","tags":["React"],"title":"受控组件和非受控组件","uri":"/controlled-and-uncontrolled-components/"},{"categories":["React"],"content":"3 Uncontrolled Components 针对 Uncontrolled Elements，React 使用 ref 对其进行引用，value 依旧是存储在 DOM 里，引用可以看似 document.querySelector() 这样的 DOM 操作。 ","date":"2021-04-15","objectID":"/controlled-and-uncontrolled-components/:3:0","tags":["React"],"title":"受控组件和非受控组件","uri":"/controlled-and-uncontrolled-components/"},{"categories":["React"],"content":"4 Codepen Example ","date":"2021-04-15","objectID":"/controlled-and-uncontrolled-components/:4:0","tags":["React"],"title":"受控组件和非受控组件","uri":"/controlled-and-uncontrolled-components/"},{"categories":["React"],"content":"5 总结 受控组件 - 体现 React 通过 state 控制元素的思想，数据都是在 React 组件的 state 里，直到被渲染到 DOM 上，DOM 更新也是根据 state 来更新。 非受控组件 - 使用 ref 来对 DOM 进行引用，类似 document.querySelector() 。 核心是：Data 在哪里！ ","date":"2021-04-15","objectID":"/controlled-and-uncontrolled-components/:5:0","tags":["React"],"title":"受控组件和非受控组件","uri":"/controlled-and-uncontrolled-components/"},{"categories":["代码技巧"],"content":"if-else❌ switch❌ table✅","date":"2021-04-14","objectID":"/refactor-ifelse-or-switch-into-table/","tags":["代码优化","重构"],"title":"重构 if-else 或 switch 成 table","uri":"/refactor-ifelse-or-switch-into-table/"},{"categories":["代码技巧"],"content":"if-else❌ if (season === \"summer\") { return \"It's 30, hot!\"; } else if (season === \"winter\") { return \"It's 2, cold!\"; } else { return \"It's 20, good!\"; } ","date":"2021-04-14","objectID":"/refactor-ifelse-or-switch-into-table/:1:0","tags":["代码优化","重构"],"title":"重构 if-else 或 switch 成 table","uri":"/refactor-ifelse-or-switch-into-table/"},{"categories":["代码技巧"],"content":"switch❌ switch (season) { case \"summer\": return \"It's 30, hot!\"; case \"winter\": return \"It's 2, cold!\"; default: return \"It's 20, good!\"; } ","date":"2021-04-14","objectID":"/refactor-ifelse-or-switch-into-table/:2:0","tags":["代码优化","重构"],"title":"重构 if-else 或 switch 成 table","uri":"/refactor-ifelse-or-switch-into-table/"},{"categories":["代码技巧"],"content":"table✅ const seasonConfig = { summer: { text: \"hot!\", temperature: 30 }, winter: { text: \"cold!\", temperature: 2 }, defaultKey: { text: \"good!\", temperature: 20 } }; function getValueFromTable(table, key, defaultKey) { return table[key] || table[defaultKey]; } const summer = getValueFromTable(seasonConfig, \"summer\", \"defaultKey\"); summerDOM.innerHTML = `It's ${summer.temperature}, ${summer.text}`; ","date":"2021-04-14","objectID":"/refactor-ifelse-or-switch-into-table/:3:0","tags":["代码优化","重构"],"title":"重构 if-else 或 switch 成 table","uri":"/refactor-ifelse-or-switch-into-table/"},{"categories":["代码技巧"],"content":"Why table✅? 因为后续加 case 的时候只需要在 table 加就行了！ 而且数据和逻辑分开了！ ","date":"2021-04-14","objectID":"/refactor-ifelse-or-switch-into-table/:4:0","tags":["代码优化","重构"],"title":"重构 if-else 或 switch 成 table","uri":"/refactor-ifelse-or-switch-into-table/"},{"categories":["代码技巧"],"content":"Why named “Table”? Code const table = { summer: { text: \"hot!\", temperature: 30 }, winter: { text: \"cold!\", temperature: 2 }, defaultKey: { text: \"good!\", temperature: 20 } }; Table Key Text Temperature summer “hot!” 30 winter “cold!” 2 defaultKey “good!” 20 这不是很 Table 嘛！ ","date":"2021-04-14","objectID":"/refactor-ifelse-or-switch-into-table/:5:0","tags":["代码优化","重构"],"title":"重构 if-else 或 switch 成 table","uri":"/refactor-ifelse-or-switch-into-table/"},{"categories":["代码技巧"],"content":"Codepen Example ","date":"2021-04-14","objectID":"/refactor-ifelse-or-switch-into-table/:6:0","tags":["代码优化","重构"],"title":"重构 if-else 或 switch 成 table","uri":"/refactor-ifelse-or-switch-into-table/"},{"categories":["工具"],"content":"实用库 FakerJS 介绍和使用","date":"2021-04-13","objectID":"/library-fakerjs/","tags":["库","JavaScript"],"title":"实用库 FakerJS","uri":"/library-fakerjs/"},{"categories":["工具"],"content":"1 简介 faker.js - generate massive amounts of fake data in the browser and node.js. faker.js - 在浏览器和 node.js 中生成大量假数据。 在开发中我们经常需要数据的临时占位，例如头像、背景图片、邮箱、电话等等数据，如果我们去临时找这些资料，会打断开发流程。 faker.js 是解决这个问题的实用库，它可以伪造各种数据，而且使用也非常简单。 ","date":"2021-04-13","objectID":"/library-fakerjs/:1:0","tags":["库","JavaScript"],"title":"实用库 FakerJS","uri":"/library-fakerjs/"},{"categories":["工具"],"content":"2 用例 API var randomEmail = faker.internet.email() Codepen 示例 每次刷新都能 fake 新的数据，非常方便。 ","date":"2021-04-13","objectID":"/library-fakerjs/:2:0","tags":["库","JavaScript"],"title":"实用库 FakerJS","uri":"/library-fakerjs/"},{"categories":["心得"],"content":"用 JavaScript 实现打字动画效果","date":"2021-03-31","objectID":"/typewriter-effect-with-javascript/","tags":["JavaScript","Animation"],"title":"JavaScript 打字效果","uri":"/typewriter-effect-with-javascript/"},{"categories":["心得"],"content":"1 打字效果 我要把下面的一段原始文本，用 JavaScript 实现打字机效果的动画。 /* Draw a Spider */ .spider { width: 400px; margin-left: auto; margin-right: auto; } 效果如图： 纯文本的打字效果typewriter-effect \" 纯文本的打字效果 语法高亮的文本打字效果typewriter-effect-with-syntax-highlight \" 语法高亮的文本打字效果 ","date":"2021-03-31","objectID":"/typewriter-effect-with-javascript/:1:0","tags":["JavaScript","Animation"],"title":"JavaScript 打字效果","uri":"/typewriter-effect-with-javascript/"},{"categories":["心得"],"content":"2 文本处理 ","date":"2021-03-31","objectID":"/typewriter-effect-with-javascript/:2:0","tags":["JavaScript","Animation"],"title":"JavaScript 打字效果","uri":"/typewriter-effect-with-javascript/"},{"categories":["心得"],"content":"2.1 纯文本 纯文字，直接放在在 \u003cpre\u003e 里就行。 \u003cpre\u003e .spider { width: 400px } \u003c/pre\u003e ","date":"2021-03-31","objectID":"/typewriter-effect-with-javascript/:2:1","tags":["JavaScript","Animation"],"title":"JavaScript 打字效果","uri":"/typewriter-effect-with-javascript/"},{"categories":["心得"],"content":"2.2 语法高亮 语法高亮，基本原理是把原始文本的关键词拆分，放进 \u003cspan\u003e 标签内，搭配 CSS 生效样式。 实现语法高亮的库有 Prism.js、 highlight.js 等，这里我使用 Prism.js。 生成的 DOM 如下： \u003cpre\u003e \u003cspan class=\"token selector\"\u003e.spider\u003c/span\u003e \" \" \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e \" \" \u003cspan class=\"token property\"\u003ewidth\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \" 400px\" \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e \u003c/pre\u003e ","date":"2021-03-31","objectID":"/typewriter-effect-with-javascript/:2:2","tags":["JavaScript","Animation"],"title":"JavaScript 打字效果","uri":"/typewriter-effect-with-javascript/"},{"categories":["心得"],"content":"3 打字动画 ","date":"2021-03-31","objectID":"/typewriter-effect-with-javascript/:3:0","tags":["JavaScript","Animation"],"title":"JavaScript 打字效果","uri":"/typewriter-effect-with-javascript/"},{"categories":["心得"],"content":"3.1 纯文本 纯文本只需要每秒更新一次 innerHTML 就行。 let addText = `/* Draw a Spider */ .spider { width: 400px; margin-left: auto; margin-right: auto; }`; let i = 0; let time = 1000; function typeWriter() { if (i \u003c addText.length) { document.querySelector(\"pre\").innerHTML += addText.charAt(i); i++; setTimeout(typeWriter, time); } } ","date":"2021-03-31","objectID":"/typewriter-effect-with-javascript/:3:1","tags":["JavaScript","Animation"],"title":"JavaScript 打字效果","uri":"/typewriter-effect-with-javascript/"},{"categories":["心得"],"content":"3.2 语法高亮 语法高亮也是更新 innerHTML，但是经过 Prism.highlight() 处理。 let addText = `/* Draw a Spider */ .spider { width: 400px; margin-left: auto; margin-right: auto; }`; let i = 0; let time = 1000; let currentText = \"\"; function typeWriter() { if (i \u003c addText.length) { currentText += addText.charAt(i); const highlightedText = Prism.highlight(currentText, Prism.languages.css); document.querySelector(\"pre\").innerHTML = highlightedText; i++; setTimeout(typeWriter, time); } } 注意 这里不能用 innerHTML += addText.charAt(i)，而是用 currentText，因为 innerHTML 是被语法高亮的 \u003cspan\u003e 分割并包裹的。 \u003cpre id=\"code\"\u003e \u003cspan class=\"token comment\"\u003e/* Draw a Spider */\u003c/span\u003e ... \u003c/pre\u003e ","date":"2021-03-31","objectID":"/typewriter-effect-with-javascript/:3:2","tags":["JavaScript","Animation"],"title":"JavaScript 打字效果","uri":"/typewriter-effect-with-javascript/"},{"categories":["心得"],"content":"4 改进性能 ","date":"2021-03-31","objectID":"/typewriter-effect-with-javascript/:4:0","tags":["JavaScript","Animation"],"title":"JavaScript 打字效果","uri":"/typewriter-effect-with-javascript/"},{"categories":["心得"],"content":"4.1 insertAdjacentHTML 比 innerHTML 更高效 innerHTML 替换整个 pre 节点element-replace \" innerHTML 替换整个 pre 节点 insertAdjacentHTML 插入节点element-append \" insertAdjacentHTML 插入节点 element.innerHTML 是 replace替换 整个节点。 insertAdjacentHTML 是 insert插入 到节点。 替换是要移除整个节点，再放入新节点；而插入是在原来的节点里插入的，性能更佳。 更多 insert插入 的 API ParentNode.prepend() 在父节点的第一个子节点之前插入一系列Node对象或者DOMString对象。 ParentNode.append() 在父节点的最后一个子节点之后插入一组 Node 对象或 DOMString 对象。 Node.appendChild() 将一个节点附加到指定父节点的子节点列表的末尾处。 ","date":"2021-03-31","objectID":"/typewriter-effect-with-javascript/:4:1","tags":["JavaScript","Animation"],"title":"JavaScript 打字效果","uri":"/typewriter-effect-with-javascript/"},{"categories":["心得"],"content":"4.2 纯文本的 insert 纯文本很简单，因为没有嵌套结构。 - document.querySelector(\"pre\").innerHTML += addText.charAt(i); + document.querySelector(\"pre\").insertAdjacentHTML(\"beforeend\", addText.charAt(i)); DOM 结果如下 \u003cpre id=\"code\"\u003e \".\" \"s\" \"p\" ... \u003c/pre\u003e ","date":"2021-03-31","objectID":"/typewriter-effect-with-javascript/:4:2","tags":["JavaScript","Animation"],"title":"JavaScript 打字效果","uri":"/typewriter-effect-with-javascript/"},{"categories":["心得"],"content":"4.3 语法高亮的 insert 语法高亮比较麻烦，因为要处理嵌套，找出 text 节点来分割。 曾经试过用正则表达式来处理，做成一个扁平化的 HTML 文本，如下： \u003cpre class=\"code\"\u003e \u003cspan class=\"token comment\"\u003e.\u003c/span\u003e \u003cspan class=\"token comment\"\u003es\u003c/span\u003e \u003cspan class=\"token comment\"\u003ep\u003c/span\u003e \u003c/pre\u003e 后来发觉 HTML 的嵌套关系太复杂，用正则表达式匹配嵌套的 HTML 似乎是个作死行为😭。 幻想匹配 \u003cspan\u003e 套 \u003cspan\u003e 套 文本 \u003cspan\u003e \u003cspan\u003eH\u003c/span\u003e \u003c/span\u003e 结果 😭 \u003cspan\u003e\u003cspan\u003eH\u003c/span\u003e \u003c/span\u003e 暂时用 typewriterjs 吧，有空自己再实现。 ","date":"2021-03-31","objectID":"/typewriter-effect-with-javascript/:4:3","tags":["JavaScript","Animation"],"title":"JavaScript 打字效果","uri":"/typewriter-effect-with-javascript/"},{"categories":["心得"],"content":"5 总结 对于 DOM 操作，insert插入 往往比 replace替换 更高效。 用正则表达式去解析 HTML，大失败！ ","date":"2021-03-31","objectID":"/typewriter-effect-with-javascript/:5:0","tags":["JavaScript","Animation"],"title":"JavaScript 打字效果","uri":"/typewriter-effect-with-javascript/"},{"categories":["流程"],"content":"用 Hugo 建立博客","date":"2021-03-25","objectID":"/building-blog-with-hugo/","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"1 简介 这篇文章是我使用 Hugo 搭建博客的一个流程记录，这里不会涉及思路、原理之类，仅仅是方便快速回顾。 ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:1:0","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"2 工具选择 Hugo - 建站框架 Github page - 部署静态网站 ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:2:0","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"3 项目管理 ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:3:0","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"3.1 两个 github 仓库 Hugo-Blog - Hugo 博客项目，用于构建静态网站。 \u003cYourGithubName\u003e.github.io - 部署到 Github Page 的项目。 ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:3:1","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"3.2 Hugo-Blog 项目结构 Hugo-Blog ├── archetypes │ └── default.md # 新建 Post 的 Markdown 模版 ├── assets # 不定资源，例如 images/avatar.png ├── config.toml # Hugo 配置文件 ├── content # 页面内容 │ ├── about.md │ └── posts │ └── first-post.md ├── public # Hugo 构建的网站 │ ├── index.html │ └── index.json # algolia 搜索需要的索引文件 ├── static # 固定资源，例如 favicon.ico │ └── favicon.ico └── themes # 主题 ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:3:2","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"3.3 \u003cYourGithubName\u003e.github.io 项目结构 public └── index.html # 网站主入口 ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:3:3","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"3.4 git submodule 管理方案 Hugo-Blog # 主项目 ├── public # 子模块: \u003cYourGithubName\u003e.github.io | 发布的网站 └── themes └── Coder # 子模块: Coder | 第三方主题 git submodule 可以让主项目不管子模块，有需要时才获取子模块的更新。 submodule 的文件夹不需要添加到 .gitignore，因为它不用主项目来管。 ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:3:4","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"4 Hugo-Blog 项目搭建 ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:4:0","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"4.1 创建 Hugo 项目 # 安装 Hugo brew install hugo # 新建 Hugo 项目 hugo new site Hugo-Blog # 进入项目目录 cd Hugo-Blog ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:4:1","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"4.2 安装主题 # 以 submodule 安装 theme git init git submodule add https://github.com/\u003ctheme\u003e/\u003ctheme\u003e.git themes/\u003ctheme\u003e ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:4:2","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"4.3 配置主题 根据主题的要求去配置，不同主题有不同的配置，可以参考主题下的 exampleSite 去配置。 配置文件是 config.toml，基础配置如下： baseURL = \"http://example.org/\" # 网站标题 title = \"My Blog\" # 主题 theme = \"Coder\" ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:4:3","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"4.4 新建 Post hugo new posts/my-first-post.md ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:4:4","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"4.5 启动本地服务 # 启动本地服务 hugo serve # -D 表示草稿 Post 也展示 hugo serve -D ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:4:5","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"4.5 构建网站 # 构建网站到 public 文件夹 hugo # -D 表示草稿 Post 也构建 hugo -D ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:4:6","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"5 \u003cYourGithubName\u003e.github.io 项目搭建 ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:5:0","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"5.1 新建 github repository 新建 \u003cYourGithubName\u003e.github.io 的公开仓库，这里的\u003cYourGithubName\u003e 是指你的 github 账户名，例如 alex.github.io。 ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:5:1","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"5.2 Push 到 repository # 从 Hugo-Blog 进入 public cd public # Push 到 repository git init git commit -m \"first commit\" git branch -M main git remote add origin https://github.com/\u003cYourGithubName\u003e/\u003cYourGithubName\u003e.github.io.git git push -u origin main ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:5:2","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"6 Hugo-Blog 项目 Push 到 Github # 从 public 进入 Hugo-Blog cd .. # 删除 public rm -rf public # 以 submodule 添加 public git submodule add https://github.com/\u003cYourGithubName\u003e/\u003cYourGithubName\u003e.github.io.git public # Push 到 repository git add . git commit -m \"Init Hugo-Blog\" git branch -M main git remote add origin https://github.com/\u003cYourGithubName\u003e/Hugo-Blog.git git push -u origin main ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:6:0","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"7 添加 algolia 搜索 ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:7:0","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"7.1 生成 index.json 注册 algolia 并创建一个 application， Indices 里 创建一个新的 index，命名例如 index_zh-cn。 它需要的是一个 index.json 文件，文件内容大概如下： [ { \"categories\": [\"Test\"], \"content\": \"Markdown 语法测试。\", \"date\": \"2021-03-25\", \"objectID\": \"/markdown-test/\", \"tags\": [\"test\"], \"title\": \"Markdown 测试\", \"uri\": \"/markdown-test/\" } ] Hugo 可以生成这么一个 index.json 文件，在配置里添加： [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] 构建网站时，生产 index.json hugo 文件位置 public ├── index.json # Hugo 生成的 Algolia 需要的文件 └── index.html ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:7:1","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"7.2 搜索配置 根据主题的要求配置搜索引擎 [params.search] enable = true # 搜索引擎的类型 type = \"algolia\" [params.search.algolia] index = \"index_zh-cn\" appID = \"XXXXXXXX\" searchKey = \"YYYYYYYYYYYYY\" ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:7:2","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"},{"categories":["流程"],"content":"7.3 使用 Algolia Atomic 上传 index.json 安装 Algolia Atomic npm init npm install atomic-algolia 添加运行命令到 package.json \"scripts\": { \"algolia\": \"atomic-algolia\" }, 新建环境变量文件 .env，把 Algolia - API Keys 存放到里面。 注意：Admin Key 是很重要的，不要把它暴露出来，记得要在 .gitignore 里添加 .env。 ALGOLIA_APP_ID=\"XXXXXXXX\" ALGOLIA_ADMIN_KEY=\"ZZZZZZZZZZZZZZZZZ\" ALGOLIA_INDEX_NAME=\"index_zh-cn\" # Algolia - Indices - index_zh-cn ALGOLIA_INDEX_FILE=\"public/index.json\" # hugo 生产的 index.json 上传文件到 algolia npm run algolia 完成！ ","date":"2021-03-25","objectID":"/building-blog-with-hugo/:7:3","tags":["Hugo","博客"],"title":"用 Hugo 建立博客","uri":"/building-blog-with-hugo/"}]